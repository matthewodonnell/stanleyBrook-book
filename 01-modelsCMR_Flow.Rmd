## Flow effects on survival (phi) models {#modelCMR_Flow}

The goal of this modelling exercise is to evaluate the effect of new tributary-specific stream flow estimates on survival of brook trout and brown trout. We will compare survival across the WB and tributaries with flow input data as 1) single flow estimate for all locations (historical approach) and 2) hindcasted flows for each tributary based on new tributary-specific flows which are available since 2000.

The goal is to find the best structure for the survival model, then compare survival estimates with tributary-specific flow to estimates with common flow across locations.

Structure options include
[species, cohort, season, isYOY, flow, flow^2]


```{r globalModelsNimble, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```


```{r librariesModelsNimble, echo = FALSE}
library(getWBData)
library(lubridate)
library(kableExtra)
library(GGally)
library(nimble)
library(MCMCvis)
library(tidyverse)
```

```{r}
rerunSurivalModels <- FALSE
plotMCMCOutput <- TRUE
```


```{r}
load('./models/cmrFlowWB/dataOut/eh_2002200320042005200620072008200920102011201220132014_wb obear.RData')
```

### Model phi_p 
Single estimates of phi and p (across, time, cohorts, flow)
#### Set up and run model
```{r phi_p}
# Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/4_demo.html

if (rerunSurivalModels) {
  y <- eh$eh
  
  nSeasons <- nrow(unique(eh$seasons))
  nCohorts <- nrow(unique(eh$cohorts))
  
  hmm.phi_p <- nimbleCode({
    phi ~ dunif(0, 1) # prior survival
    p ~ dunif(0, 1) # prior detection
    # likelihood
    gamma[1,1] <- phi      # Pr(alive t -> alive t+1)
    gamma[1,2] <- 1 - phi  # Pr(alive t -> dead t+1)
    gamma[2,1] <- 0        # Pr(dead t -> alive t+1)
    gamma[2,2] <- 1        # Pr(dead t -> dead t+1)
    delta[1] <- 1          # Pr(alive t = 1) = 1
    delta[2] <- 0          # Pr(dead t = 1) = 0
    omega[1,1] <- 1 - p    # Pr(alive t -> non-detected t)
    omega[1,2] <- p        # Pr(alive t -> detected t)
    omega[2,1] <- 1        # Pr(dead t -> non-detected t)
    omega[2,2] <- 0        # Pr(dead t -> detected t)
    
    for (i in 1:N){
      z[i,first[i]] ~ dcat(delta[1:2])
      for (j in (first[i]+1):last[i]){
        z[i,j] ~ dcat(gamma[z[i,j-1], 1:2])
        y[i,j] ~ dcat(omega[z[i,j], 1:2])
      }
    }
  })
    
  first <- eh$first #apply(y, 1, function(x) min(which(x !=0)))
  last <- eh$last
  
  myConstants <- list(N = nrow(y), 
                       T = ncol(y), 
                       first = first,
                       last = last)
  
  myData <- list(y = y + 1)
  
  zinits <- y + 1 # non-detection -> alive
  zinits[zinits == 2] <- 1 # dead -> alive
  initialValues <- function() list(phi = runif(1,0,1),
                                    p = runif(1,0,1),
                                    z = zinits
                                    )
  
  
  parametersToSave <- c("phi", "p")  
  nIter <- 5000
  nBurnin <- 1000
  nChains <- 2
  thinRate = 5
  
  start <- Sys.time()
  
  Rmodel <- nimbleModel(
    code = hmm.phi_p, 
    constants = myConstants,
    data = myData,              
    inits = initialValues(),
    calculate = FALSE
  )
  conf <- configureMCMC(
    Rmodel,
    monitors = parametersToSave
  )
  
  Rmcmc <- buildMCMC(conf, useConjugacy = FALSE)
  Cmodel <- compileNimble(Rmodel)
  Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
  
  mcmc.phi_p <- runMCMC(
    Cmcmc, 
    niter = nIter, 
    nburnin = nBurnin, 
    thin = thinRate, 
    nchains = nChains
  )
  
  end <- Sys.time()
  elapsed_phi_p <- end - start
  toSave <- list(
    mcmc = mcmc.phi_p, 
    elapsed = elapsed_phi_p,
    name = "phi_p",
    myConstants = myConstants, 
    nIter = nIter, 
    nBurnin = nBurnin,
    thinRate = thinRate, 
    nSeasons = nSeasons, 
    nCohorts = nCohorts,
    nChains = nChains
  )
  save(toSave, file = paste0('./models/cmrFlowSB/runsOut/mcmc_phi_p_', substr(end,1,13), '.RData'))
  save(toSave, file = './models/cmrFlowWB/runsOut/mcmc_phi_p_mostRecent.RData')
} else {
  load('./models/cmrFlowWB/runsOut/mcmc_phi_p_mostRecent.RData')
}

if(plotMCMCOutput) {
  #MCMCsummary(object = mcmc.phi_p, round = 2)
  MCMCplot(object = toSave$mcmc)
  
  priors <- runif(toSave$nIter * toSave$nChains, 0, 1)
  MCMCtrace(object = toSave$mcmc,
            ISB = FALSE,
            exact = TRUE, 
            params = c("phi", "p"),
            pdf = FALSE, 
            priors = priors)
}
```

### Model phiT_pT
Phi and p vary by sampling occasion (time)
#### Set up and run model
```{r phiT_pT}

# Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/4_demo.html
if (rerunSurivalModels) {

  y <- eh$eh
  nSeasons <- nrow(unique(eh$seasons))
  nCohorts <- nrow(unique(eh$cohorts))
  
  hmm.phiT_pT <- nimbleCode({
    delta[1] <- 1                    # Pr(alive t = 1) = 1
    delta[2] <- 0                    # Pr(dead t = 1) = 0
    for (t in 1:(T-1)){ # loop over time
      phi[t] ~ dunif(0, 1)           # prior survival
      gamma[1,1,t] <- phi[t]         # Pr(alive t -> alive t+1)
      gamma[1,2,t] <- 1 - phi[t]     # Pr(alive t -> dead t+1)
      gamma[2,1,t] <- 0              # Pr(dead t -> alive t+1)
      gamma[2,2,t] <- 1              # Pr(dead t -> dead t+1)
      p[t] ~ dunif(0, 1)             # prior detection
      omega[1,1,t] <- 1 - p[t]       # Pr(alive t -> non-detected t)
      omega[1,2,t] <- p[t]           # Pr(alive t -> detected t)
      omega[2,1,t] <- 1              # Pr(dead t -> non-detected t)
      omega[2,2,t] <- 0              # Pr(dead t -> detected t)
    }
    # likelihood
    for (i in 1:N){
      z[i,first[i]] ~ dcat(delta[1:2])
      for (j in (first[i]+1):last[i]){
        z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1])
        y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1])
      }
    }
  })
    
  first <- eh$first #apply(y, 1, function(x) min(which(x !=0)))
  last <- eh$last
  
  myConstants <- list(N = nrow(y), 
                       T = ncol(y), 
                       first = first,
                       last = last)
  
  myData <- list(y = y + 1)
  
  zinits <- y + 1 # non-detection -> alive
  zinits[zinits == 2] <- 1 # dead -> alive
  
  initialValues <- function() list(phi = runif(myConstants$T - 1, 0, 1),
                                    p = runif(myConstants$T - 1, 0, 1),
                                    z = zinits)
  
  parametersToSave <- c("phi", "p")  
  nIter <- 5000
  nBurnin <- 1000
  nChains <- 2
  thinRate <- 5
  
  start <- Sys.time()
  
  Rmodel <- nimbleModel(
    code = hmm.phiT_pT, 
    constants = myConstants,
    data = myData,              
    inits = initialValues(),
    calculate = FALSE
  )
  conf <- configureMCMC(
    Rmodel,
    monitors = parametersToSave
  )
  
  Rmcmc <- buildMCMC(conf, useConjugacy = FALSE)
  Cmodel <- compileNimble(Rmodel)
  Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
  
  mcmc.phiT_pT <- runMCMC(
    Cmcmc, 
    niter = nIter, 
    nburnin = nBurnin, 
    thin = thinRate, 
    nchains = nChains
  )
  
  
  
  end <- Sys.time()
  elapsed_phiT_pT <- end - start
    toSave <- list(
      mcmc = mcmc.phiT_pT, 
      elapsed = elapsed_phiT_pT,
      name = "phiT_pT",
      myConstants = myConstants, 
      nIter = nIter, 
      nBurnin = nBurnin,
      thinRate = thinRate, 
      nSeasons = nSeasons, 
      nCohorts = nCohorts,
      nChains = nChains
    )
  save(toSave, file = paste0('./models/cmrFlowsB/runsOut/mcmc_phiT_pT_', substr(end,1,13), '.RData'))
  save(toSave, file = './models/cmrFlowSB/runsOut/mcmc_phiT_pT_mostRecent.RData')
} else {
  load('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_mostRecent.RData')
}
  
if (plotMCMCOutput) {  
  #MCMCsummary(object = mcmc.phiT_pT, round = 2)
  MCMCplot(object = toSave$mcmc)
  
  priors <- runif(toSave$nIter * toSave$nChains, 0, 1)
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            #params = c("phi[1]", "phi[2]", "phi[3]", "phi[4]", "phi[5]", "phi[9]", "phi[10]",
            #           "p[1]", "p[2]", "p[3]", "p[4]", "p[5]"),
            params = c("phi"),
            pdf = FALSE, 
            priors = priors)
}

```

### Model phiT_pT_isYOY
Add structure for isYOY. This was important for the integrated growth/survival model, but probably not relevant here since we are estimating phi and p for each ageInSamples
```{r phiT_pT_cohortisYOY}

# Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/4_demo.html
if (rerunSurivalModels) {

  y <- eh$eh
  nSeasons <- nrow(unique(eh$seasons))
  nCohorts <- nrow(unique(eh$cohorts))
  
  hmm.phiT_pT_isYOY <- nimbleCode({
    delta[1] <- 1                    # Pr(alive t = 1) = 1
    delta[2] <- 0                    # Pr(dead t = 1) = 0

    for (i in 1:N){
      for (t in 1:(T-1)){ # loop over time
        #logit(phi[t,i]) <- betaPhi[t,isYOY[i,t]]           # prior survival
        logit(phi[t,i]) <- betaPhi[t]    # prior survival
        gamma[1,1,t,i] <- phi[t,i]       # Pr(alive t -> alive t+1)
        gamma[1,2,t,i] <- 1 - phi[t,i]   # Pr(alive t -> dead t+1)
        gamma[2,1,t,i] <- 0              # Pr(dead t -> alive t+1)
        gamma[2,2,t,i] <- 1              # Pr(dead t -> dead t+1)

        logit(p[t,i]) <- betaP[t]        # prior detection
        omega[1,1,t,i] <- 1 - p[t,i]     # Pr(alive t -> non-detected t)
        omega[1,2,t,i] <- p[t,i]         # Pr(alive t -> detected t)
        omega[2,1,t,i] <- 1              # Pr(dead t -> non-detected t)
        omega[2,2,t,i] <- 0              # Pr(dead t -> detected t)
      }
    }

    for (y in 1:2){
      # mean values
      betaPhiIsYOY[y] ~ dnorm(0,1)
      betaPIsYOY[y] ~ dnorm(0,1)
    }
    
    # isYOY = 1
    for (t in 1:3){ 
      betaPhi[t] ~ dnorm(betaPhiIsYOY[1], 1)
      betaP[t] ~ dnorm(betaPIsYOY[1], 1)
    }
    # isYOY = 2, older fish
    for (t in 4:(T-1)){ 
      betaPhi[t] ~ dnorm(betaPhiIsYOY[2], 1)
      betaP[t] ~ dnorm(betaPIsYOY[2], 1)
    }
    
    # Backtransform for output
    for (y in 1:2){
        betaPhiIsYOYOut[y] <- 1/(1 + exp(-betaPhiIsYOY[y]))
        betaPIsYOYOut[y] <- 1/(1 + exp(-betaPIsYOY[y]))
    }
    for (t in 1:(T-1)){ 
      betaPhiOut[t] <- 1/(1 + exp(-betaPhi[t]))
      betaPOut[t] <- 1/(1 + exp(-betaP[t])) 
    }
    
    
    # likelihood
    for (i in 1:N){
      z[i,first[i]] ~ dcat(delta[1:2])
      for (j in (first[i]+1):last[i]){
        z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1, i])
        y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1, i])
      }
    }
  })

  first <- eh$first #apply(y, 1, function(x) min(which(x !=0)))
  last <- eh$last

  myConstants <- list(N = nrow(y),
                      T = ncol(y),
                      first = first,
                      last = last,
                      isYOY = eh$isYOY
                      )

  myData <- list(y = y + 1)

  zinits <- y + 1 # non-detection -> alive
  zinits[zinits == 2] <- 1 # dead -> alive
  zInitsNA <- ifelse(is.na(eh$isYOY), NA, 1)

  initialValues <- function() list(
    phi = array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
    p =   array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
    z = zInitsNA,
    betaPhi = array(runif((myConstants$T - 1), 0, 1),c((myConstants$T - 1))),
    betaP = array(runif((myConstants$T - 1), 0, 1),c((myConstants$T - 1))),
    betaPhiIsYOY = array(runif(2, 0, 1),c(2)),
    betaPIsYOY = array(runif(2, 0, 1),c(2))
  )

  parametersToSave <- c("betaPhiOut", "betaPOut", "betaPIsYOYOut", "betaPhiIsYOYOut")
  nIter <- 20000
  nBurnin <- 10000
  nChains <- 2
  thinRate <- 5

  start <- Sys.time()
  Rmodel <- nimbleModel(
    code = hmm.phiT_pT_isYOY,
    constants = myConstants,
    data = myData,
    inits = initialValues(),
    calculate = FALSE
  )
  conf <- configureMCMC(
    Rmodel,
    monitors = parametersToSave
  )

  Rmcmc <- buildMCMC(conf, useConjugacy = FALSE)
  Cmodel <- compileNimble(Rmodel)
  Cmcmc <- compileNimble(Rmcmc, project = Rmodel)

  mcmc.phiT_pT_isYOY <- runMCMC(
    Cmcmc,
    niter = nIter,
    nburnin = nBurnin,
    thin = thinRate,
    nchains = nChains
  )

  end <- Sys.time()
  elapsed_phiT_pT_isYOY <- end - start

    toSave <- list(
      mcmc = mcmc.phiT_pT_isYOY,
      elapsed = elapsed_phiT_pT_isYOY,
      myConstants = myConstants,
      nIter = nIter,
      nBurnin = nBurnin,
      thinRate = thinRate,
      nSeasons = nSeasons,
      nCohorts = nCohorts,
      nChains = nChains
    )
  save(toSave, file = paste0('./models/cmrFlowSB/runsOut/mcmc_phiT_pT_isYOY_', substr(end,1,13), '.RData'))
  save(toSave, file = './models/cmrFlowSB/runsOut/mcmc_phiT_pT_isYOY_mostRecent.RData')
} else {
  load('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_isYOY_mostRecent.RData')
}

if(plotMCMCOutput) {
  MCMCsummary(object = toSave$mcmc, round = 2)
  
  MCMCplot(object = toSave$mcmc, params = "betaPhiIsYOYOut")
  MCMCplot(object = toSave$mcmc, params = "betaPhiOut")
  MCMCplot(object = toSave$mcmc, params = "betaPOut")#

  priors <-  runif(toSave$nIter * toSave$nChains, 0, 1)
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE,
            params = c("betaPhiOut"),
            pdf = FALSE,
            priors = priors)

}

```


### Model phiT_pT_cohort
Phi and p vary by time and there is a cohort effect on phi
#### Set up and run model
```{r phiT_pT_cohort}

# Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/4_demo.html
if (rerunSurivalModels) {

  y <- eh$eh
  nCohorts <- nrow(unique(eh$cohorts))
  
  hmm.phiT_pT_cohort <- nimbleCode({
    delta[1] <- 1                    # Pr(alive t = 1) = 1
    delta[2] <- 0                    # Pr(dead t = 1) = 0
    
    for (i in 1:N){
      for (t in 1:(T-1)){ # loop over time
        logit(phi[t,i]) <- betaPhi[t,cohort[i]]           # prior survival
        gamma[1,1,t,i] <- phi[t,i]         # Pr(alive t -> alive t+1)
        gamma[1,2,t,i] <- 1 - phi[t,i]     # Pr(alive t -> dead t+1)
        gamma[2,1,t,i] <- 0              # Pr(dead t -> alive t+1)
        gamma[2,2,t,i] <- 1              # Pr(dead t -> dead t+1)
        
        logit(p[t,i]) <- betaP[t,cohort[i]]             # prior detection
        omega[1,1,t,i] <- 1 - p[t,i]       # Pr(alive t -> non-detected t)
        omega[1,2,t,i] <- p[t,i]           # Pr(alive t -> detected t)
        omega[2,1,t,i] <- 1              # Pr(dead t -> non-detected t)
        omega[2,2,t,i] <- 0              # Pr(dead t -> detected t)
      }
    }
    
    
    for (c in 1:nCohorts){
      # mean values
      betaPhiCohort[c] ~ dnorm(0,1)
      betaPCohort[c] ~ dnorm(0,1)
      for (t in 1:(T-1)){ 
        betaPhi[t,c] ~ dnorm(betaPhiCohort[c], 1)
        betaP[t,c] ~ dnorm(betaPCohort[c], 1)
      }
    }
    
    # back-transform for examining output
    for (c in 1:nCohorts){
        betaPhiCohortOut[c] <- 1/(1 + exp(-betaPhiCohort[c]))
        betaPCohortOut[c] <- 1/(1 + exp(-betaPCohort[c]))
      for (t in 1:(T-1)){ 
        betaPhiOut[t,c] <- 1/(1 + exp(-betaPhi[t,c]))
        betaPOut[t,c] <- 1/(1 + exp(-betaP[t,c])) 
      }
    }
    
    # likelihood
    for (i in 1:N){
      z[i,first[i]] ~ dcat(delta[1:2])
      for (j in (first[i]+1):last[i]){
        z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1, i])
        y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1, i])
      }
    }
  })
    
  first <- eh$first #apply(y, 1, function(x) min(which(x !=0)))
  last <- eh$last
  cohort = ((eh$cohorts) - min(eh$cohorts) + 1)$cohort #can't be a data frame or tibble
  
  myConstants <- list(N = nrow(y), 
                       T = ncol(y), 
                       first = first,
                       last = last,
                       cohort = cohort, 
                       nCohorts = nCohorts
                       )
  
  myData <- list(y = y + 1)
  
  zinits <- y + 1 # non-detection -> alive
  zinits[zinits == 2] <- 1 # dead -> alive
  
  initialValues <- function() list(
    phi = array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
    p = array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
    z = zinits,
    betaPhi = array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
    betaP = array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
    betaPhiCohort = array(runif(nCohorts, 0, 1),c(nCohorts)),
    betaPCohort = array(runif(nCohorts, 0, 1),c(nCohorts))
  )
  
  parametersToSave <- c("betaPhiOut", "betaPOut", "betaPhiCohortOut", "betaPCohortOut")  
  nIter <- 5000
  nBurnin <- 2000
  nChains <- 2
  thinRate = 5
  
  start <- Sys.time()
  Rmodel <- nimbleModel(
    code = hmm.phiT_pT_cohort, 
    constants = myConstants,
    data = myData,              
    inits = initialValues(),
    calculate = FALSE
  )
  conf <- configureMCMC(
    Rmodel,
    monitors = parametersToSave
  )
  
  Rmcmc <- buildMCMC(conf, useConjugacy = FALSE)
  Cmodel <- compileNimble(Rmodel)
  Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
  
  mcmc.phiT_pT_cohort <- runMCMC(
    Cmcmc, 
    niter = nIter, 
    nburnin = nBurnin, 
    thin = thinRate, 
    nchains = nChains
  )
  
  end <- Sys.time()
  elapsed_phiT_pT_cohort <- end - start
  
  toSave <- list(
    mcmc = mcmc.phiT_pT_cohort, 
    elapsed = elapsed_phiT_pT_cohort,
    name = "phiT_pT_cohort",
    myConstants = myConstants, 
    nIter = nIter, 
    nBurnin = nBurnin,
    thinRate = thinRate, 
    nSeasons = nSeasons, 
    nCohorts = nCohorts,
    nChains = nChains
  )
  
  save(toSave, file = paste0('./models/cmrFlowSB/runsOut/mcmc_phiT_pT_cohort_', substr(end,1,13), '.RData'))
  save(toSave, file = './models/cmrFlowSB/runsOut/mcmc_phiT_pT_cohort_mostRecent.RData')
} else {
  load('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_mostRecent.RData')
}

MCMCsummary(object = mcmc.phiT_pT_cohort, round = 2)

  
if(plotMCMCOutput) { 

  MCMCplot(object = toSave$mcmc, params = c("betaPhiOut"))
  MCMCplot(object = toSave$mcmc, params = c("betaPhiCohortOut"))
  MCMCplot(object = toSave$mcmc, params = c("betaPCohortOut"))
  
  priors <- runif(toSave$nIter * toSave$nChains, 0, 1)
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaPhiCohortOut", "betaPCohortOut"),
            pdf = FALSE, 
            priors = priors)
}

```

#### Plot phi against flow data phiT_pT_cohort
```{r plot phi and raw flow}
phiOut <- MCMCsummary(toSave$mcmc, params = 'betaPhiOut')


```


### Model phiT_pT_cohort_flow
Add mean flow over the interval as a survival effect
#### Set up and run model
```{r phiT_pT_cohort_flow}

# Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/4_demo.html
if (rerunSurivalModels) {

  y <- eh$eh
  nCohorts <- nrow(unique(eh$cohorts))
  nSeasons <- nrow(unique(eh$seasons))
  seasonArray <- c(3,4,1,2,3,4,1,2,3,4,1,2)
  
  hmm.phiT_pT_cohort_flow <- nimbleCode({
    delta[1] <- 1                    # Pr(alive t = 1) = 1
    delta[2] <- 0                    # Pr(dead t = 1) = 0
    
    for (i in 1:N){
      for (t in 1:(T-1)){ # loop over time
        logit(phi[t,i]) <- 
          betaInt +
          betaPhi[t,cohort[i]] + 
          betaFlow[1,season[t]] * flow[i,t] +
          betaFlow[2,season[t]] * flow[i,t] * flow[i,t]
           # prior survival
        
        gamma[1,1,t,i] <- phi[t,i]         # Pr(alive t -> alive t+1)
        gamma[1,2,t,i] <- 1 - phi[t,i]     # Pr(alive t -> dead t+1)
        gamma[2,1,t,i] <- 0              # Pr(dead t -> alive t+1)
        gamma[2,2,t,i] <- 1              # Pr(dead t -> dead t+1)
        
        logit(p[t,i]) <- betaP[t,cohort[i]]             # prior detection
        omega[1,1,t,i] <- 1 - p[t,i]       # Pr(alive t -> non-detected t)
        omega[1,2,t,i] <- p[t,i]           # Pr(alive t -> detected t)
        omega[2,1,t,i] <- 1              # Pr(dead t -> non-detected t)
        omega[2,2,t,i] <- 0              # Pr(dead t -> detected t)
      }
    }
    
    betaInt ~ dnorm(0,1)
    
    for (c in 1:nCohorts){
      # mean values
      betaPhiCohort[c] ~ dnorm(0,1)
      betaPCohort[c] ~ dnorm(0,1)
      for (t in 1:(T-1)){ 
        betaPhi[t,c] ~ dnorm(betaPhiCohort[c], 1)
        betaP[t,c] ~ dnorm(betaPCohort[c], 1)
      }
    }
    
    # back-transform for examining output
    for (c in 1:nCohorts){
        betaPhiCohortOut[c] <- 1/(1 + exp(-betaPhiCohort[c]))
        betaPCohortOut[c] <- 1/(1 + exp(-betaPCohort[c]))
      for (t in 1:(T-1)){ 
        betaPhiOut[t,c] <- 1/(1 + exp(-betaPhi[t,c]))
        betaPOut[t,c] <- 1/(1 + exp(-betaP[t,c])) 
      }
    }
    
    for (s in 1:nSeasons){
      betaFlow[1,s] ~ dnorm(0, 1)
      betaFlow[2,s] ~ dnorm(0, 1)
    }    
    
    # likelihood
    for (i in 1:N){
      z[i,first[i]] ~ dcat(delta[1:2])
      for (j in (first[i]+1):(last[i])){
        z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1, i])
        y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1, i])
      }
    }
  })
    
  first <- eh$first #apply(y, 1, function(x) min(which(x !=0)))
  last <- eh$last
  cohort = ((eh$cohorts) - min(eh$cohorts) + 1)$cohort #can't be a data frame or tibble
  
  myConstants <- list(N = nrow(y), 
                       T = ncol(y), 
                       first = first,
                       last = last,
                       cohort = cohort, 
                       nCohorts = nCohorts,
                       season = seasonArray, #eh$seasons$season,
                       flow = eh$flow
                       )
  
  myData <- list(y = y + 1)
  
  zinits <- y + 1 # non-detection -> alive
  zinits[zinits == 2] <- 1 # dead -> alive
  
  zInitsNA <- ifelse(is.na(eh$flow), NA, 1)
  
  initialValues <- function() list(
    betaInt = rnorm(1, 0, 1),
    phi = array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
    p =   array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
    z = zInitsNA,
    betaPhi = array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
    betaP =   array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
    betaPhiCohort = array(runif(nCohorts, 0, 1),c(nCohorts)),
    betaPCohort =   array(runif(nCohorts, 0, 1),c(nCohorts)),
    betaFlow = array(rnorm(2 * 4, 0, 1), c(2, 4))
  )
  
  parametersToSave <- c("betaInt", 
                        "betaPhi", "betaP", "betaPhiCohort", "betaPCohort",
                        "betaPhiOut", "betaPOut", "betaPhiCohortOut", "betaPCohortOut", 
                        "betaFlow")  
  nIter <- 20000
  nBurnin <- 10000
  nChains <- 2
  thinRate <- 5
  
  start = Sys.time()
  
  Rmodel <- nimbleModel(
    code = hmm.phiT_pT_cohort_flow, 
    constants = myConstants,
    data = myData,              
    inits = initialValues(),
    calculate = FALSE
  )
  conf <- configureMCMC(
    Rmodel,
    monitors = parametersToSave
  )
  
  Rmcmc <- buildMCMC(conf, useConjugacy = FALSE)
  Cmodel <- compileNimble(Rmodel)
  Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
  
  mcmc.phiT_pT_cohort_flow <- runMCMC(
    Cmcmc, 
    niter = nIter, 
    nburnin = nBurnin, 
    thin = thinRate, 
    nchains = nChains
  )
  
  end <- Sys.time()
  
  elapsed_phiT_pT_cohort_flow <- end - start
  toSave <- list(
    mcmc = mcmc.phiT_pT_cohort_flow, 
    elapsed = elapsed_phiT_pT_cohort_flow,
    name = "phiT_pT_cohort_flow",
    myConstants = myConstants, 
    nIter = nIter, 
    nBurnin = nBurnin,
    thinRate = thinRate, 
    nSeasons = nSeasons, 
    nCohorts = nCohorts,
    nChains = nChains
  )
  save(toSave, file = paste0('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flow_', substr(end,1,13), '.RData'))
    save(toSave, file = './models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flow_mostRecent.RData')
} else {
  load('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flow_mostRecent.RData')
}
# could consider forward algo to speed up convergence (https://oliviergimenez.github.io/banana-book/hmmcapturerecapture.html#nimble-implementation-1)

if(plotMCMCOutput) {
  #MCMCsummary(object = toSave$mcmc, round = 2)
  #MCMCplot(object = mcmc.phiT_pT_cohort_flow, params = "betaPhiOut")
  MCMCplot(object = toSave$mcmc, params = "betaFlow")# 
  MCMCplot(object = toSave$mcmc, params = c("betaPhiCohortOut"))
  MCMCplot(object = toSave$mcmc, params = c("betaPCohortOut"))
  
  priors <- runif(toSave$nIter * toSave$nChains, 0, 1)
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaPhiCohortOut"),
            pdf = FALSE, 
            priors = priors)
  
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaFlow"),
            pdf = FALSE, 
            priors = priors)
}
# run more iterations, if necessary
# nIterAdd <- 5000
# Cmcmc$run(nIterAdd, reset = FALSE)
# more_samples <- as.matrix(Cmcmc$mvSamples)
# 
# MCMCtrace(object = more_samples,
#           #ISB = FALSE,
#           #exact = TRUE, 
#           params = c("betaFlow"),
#           pdf = FALSE, 
#           priors = priors)

```

#### Get flow effect estimates
Flow effects fixed across cohorts
```{r}
   #     betaInt +
   #     betaPhi[t,cohort[i]] + 
   #     betaFlow[1,season[t]] * flow[i,t] +
   #     betaFlow[2,season[t]] * flow[i,t] * flow[i,t]


getPredictionsFlow <- function(mcmc, everyNIters = 10, flowStep = 0.5){

  ## betaInt
  predictorsBetaInt <- expand.grid(
    iter = seq(1, dim(mcmc$chain1)[1], everyNIters)
  )
  for(i in 1:nrow(predictorsBetaInt)){
    predictorsBetaInt$betaInt[i] <- mcmc$chain1[[ predictorsBetaInt[i, "iter"], "betaInt" ]]
  }
  
  
  ## betaFlow
  predictorsBetaFlow <- expand.grid(
    iter = seq(1, dim(mcmc$chain1)[1], everyNIters),
    season = 1:toSave$nSeasons
  )
  
  for(i in 1:nrow(predictorsBetaFlow)){
    predictorsBetaFlow$betaFlow1[i] <- mcmc$chain1[[predictorsBetaFlow[i, "iter"], 
                                                   paste0("betaFlow[1, ", predictorsBetaFlow[i, "season"],
                                                          "]")
                                                  ]]
    predictorsBetaFlow$betaFlow2[i] <- mcmc$chain1[[predictorsBetaFlow[i, "iter"], 
                                                   paste0("betaFlow[2, ", predictorsBetaFlow[i, "season"],
                                                          "]")
                                                  ]]
  }
  
  ## betaPhi
  predictorsBetaPhi <- expand.grid(
    iter = seq(1, dim(mcmc$chain1)[1], everyNIters),
    cohort = 1:toSave$nCohorts
  )
  for(i in 1:nrow(predictorsBetaPhi)){
    predictorsBetaPhi$betaPhi[i] <- mcmc$chain1[[predictorsBetaPhi[i, "iter"], 
                                                   paste0("betaPhiCohort[", predictorsBetaPhi[i, "cohort"],
                                                          "]")
                                                ]]
  }

  predictorsAll <- expand.grid(
    iter = seq(1, dim(mcmc$chain1)[1], everyNIters),
    cohort = 1:toSave$nCohorts,
    season = 1:toSave$nSeasons,
    flow = seq(-1.5, 1.5, flowStep)
  )
  
  preds <- predictorsAll %>%
    left_join(predictorsBetaInt) %>%
    left_join(predictorsBetaFlow) %>%
    left_join(predictorsBetaPhi) %>%
    mutate(predPhi = plogis(betaInt + betaPhi + betaFlow1 * flow + betaFlow2 * flow^2))
  
  return(preds)
}

predFlow <- getPredictionsFlow(toSave$mcmc, everyNIters = 2)

```

#### Plot flow predictions phiT_pT_cohort_flow
```{r}
ggplot(predFlow, aes(flow, predPhi, group = iter)) +
  geom_line(alpha = 0.025) +
  facet_grid(season ~ cohort)

# ggplot(predFlow %>% filter(season ==1, cohort == 6), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.5) +
#   facet_grid(cohort ~ season)
# 
# ggplot(predFlow %>% filter(cohort == 3), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.1) +
#   facet_wrap( ~ season)
# 
# ggplot(predFlow %>% filter(season ==1), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.1) +
#   facet_wrap(~ cohort)

```

### Model phiT_pT_cohort_flowCohort
Flow effects vary by cohort
#### Set up and run model
```{r phiT_pT_cohort_flowCohort}

# Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/4_demo.html
if (rerunSurivalModels) {

  y <- eh$eh
  nCohorts <- nrow(unique(eh$cohorts))
  nSeasons <- nrow(unique(eh$seasons))
  seasonArray <- c(3,4,1,2,3,4,1,2,3,4,1,2)
  
  hmm.phiT_pT_cohort_flowCohort <- nimbleCode({
    delta[1] <- 1                    # Pr(alive t = 1) = 1
    delta[2] <- 0                    # Pr(dead t = 1) = 0
    
    for (i in 1:N){
      for (t in 1:(T-1)){ # loop over time
        logit(phi[t,i]) <- 
          betaInt +
          betaPhi[t,cohort[i]] + 
          betaFlow[1,season[t],cohort[i]] * flow[i,t] +
          betaFlow[2,season[t],cohort[i]] * flow[i,t] * flow[i,t]
           # prior survival
        
        gamma[1,1,t,i] <- phi[t,i]         # Pr(alive t -> alive t+1)
        gamma[1,2,t,i] <- 1 - phi[t,i]     # Pr(alive t -> dead t+1)
        gamma[2,1,t,i] <- 0              # Pr(dead t -> alive t+1)
        gamma[2,2,t,i] <- 1              # Pr(dead t -> dead t+1)
        
        logit(p[t,i]) <- betaP[t,cohort[i]]             # prior detection
        omega[1,1,t,i] <- 1 - p[t,i]       # Pr(alive t -> non-detected t)
        omega[1,2,t,i] <- p[t,i]           # Pr(alive t -> detected t)
        omega[2,1,t,i] <- 1              # Pr(dead t -> non-detected t)
        omega[2,2,t,i] <- 0              # Pr(dead t -> detected t)
      }
    }
    
    betaInt ~ dnorm(0,1)
    
    for (c in 1:nCohorts){
      # mean values
      betaPhiCohort[c] ~ dnorm(0,1)
      betaPCohort[c] ~ dnorm(0,1)
      for (t in 1:(T-1)){ 
        betaPhi[t,c] ~ dnorm(betaPhiCohort[c], 1)
        betaP[t,c] ~ dnorm(betaPCohort[c], 1)
      }
    }
    
    # back-transform for examining output
    for (c in 1:nCohorts){
        betaPhiCohortOut[c] <- 1/(1 + exp(-betaPhiCohort[c]))
        betaPCohortOut[c] <- 1/(1 + exp(-betaPCohort[c]))
      for (t in 1:(T-1)){ 
        betaPhiOut[t,c] <- 1/(1 + exp(-betaPhi[t,c]))
        betaPOut[t,c] <- 1/(1 + exp(-betaP[t,c])) 
      }
    }
    
    for (s in 1:nSeasons){
      for (c in 1:nCohorts){
        betaFlow[1,s,c] ~ dnorm(0, 1)
        betaFlow[2,s,c] ~ dnorm(0, 1)
      }   
    }
    
    # likelihood
    for (i in 1:N){
      z[i,first[i]] ~ dcat(delta[1:2])
      for (j in (first[i]+1):(last[i])){
        z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1, i])
        y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1, i])
      }
    }
  })
    
  first <- eh$first #apply(y, 1, function(x) min(which(x !=0)))
  last <- eh$last
  cohort = ((eh$cohorts) - min(eh$cohorts) + 1)$cohort #can't be a data frame or tibble
  
  myConstants <- list(N = nrow(y), 
                       T = ncol(y), 
                       first = first,
                       last = last,
                       cohort = cohort, 
                       nCohorts = nCohorts,
                       season = seasonArray, #eh$seasons$season,
                       flow = eh$flow
                       )
  
  myData <- list(y = y + 1)
  
  zinits <- y + 1 # non-detection -> alive
  zinits[zinits == 2] <- 1 # dead -> alive
  
  zInitsNA <- ifelse(is.na(eh$flow), NA, 1)
  
  initialValues <- function() list(
    betaInt = rnorm(1, 0, 1),
    phi = array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
    p =   array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
    z = zInitsNA,
    betaPhi = array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
    betaP =   array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
    betaPhiCohort = array(runif(nCohorts, 0, 1),c(nCohorts)),
    betaPCohort =   array(runif(nCohorts, 0, 1),c(nCohorts)),
    betaFlow = array(rnorm(2 * 4 * nCohorts, 0, 1), c(2, 4, nCohorts))
  )
  
  parametersToSave <- c("betaInt", 
                        "betaPhi", "betaP", "betaPhiCohort", "betaPCohort",
                        "betaPhiOut", "betaPOut", "betaPhiCohortOut", "betaPCohortOut", 
                        "betaFlow")  
  nIter <- 20000
  nBurnin <- 10000
  nChains <- 2
  thinRate <- 5
  
  start = Sys.time()
  
  Rmodel <- nimbleModel(
    code = hmm.phiT_pT_cohort_flowCohort, 
    constants = myConstants,
    data = myData,              
    inits = initialValues(),
    calculate = FALSE
  )
  conf <- configureMCMC(
    Rmodel,
    monitors = parametersToSave
  )
  
  Rmcmc <- buildMCMC(conf, useConjugacy = FALSE)
  Cmodel <- compileNimble(Rmodel)
  Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
  
  mcmc.phiT_pT_cohort_flowCohort <- runMCMC(
    Cmcmc, 
    niter = nIter, 
    nburnin = nBurnin, 
    thin = thinRate, 
    nchains = nChains
  )
  
  end <- Sys.time()
  
  elapsed_phiT_pT_cohort_flowCohort <- end - start
  toSave <- list(
    mcmc = mcmc.phiT_pT_cohort_flowCohort, 
    elapsed = elapsed_phiT_pT_cohort_flowCohort,
    name = "phiT_pT_cohort_flowCohort",
    myConstants = myConstants, 
    nIter = nIter, 
    nBurnin = nBurnin,
    thinRate = thinRate, 
    nSeasons = nSeasons, 
    nCohorts = nCohorts,
    nChains = nChains
  )
  save(toSave, file = paste0('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohort_', substr(end,1,13), '.RData'))
  save(toSave, file = './models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohort_mostRecent.RData')
} else {
  load('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohort_mostRecent.RData')
}
# could consider forward algo to speed up convergence (https://oliviergimenez.github.io/banana-book/hmmcapturerecapture.html#nimble-implementation-1)

if(plotMCMCOutput) {

  #MCMCsummary(object = mcmc.phiT_pT_cohort_flow, round = 2)
  #MCMCplot(object = mcmc.phiT_pT_cohort_flow, params = "betaPhiOut")
  MCMCplot(object = toSave$mcmc, params = "betaFlow")# 
  MCMCplot(object = toSave$mcmc, params = c("betaPhiCohortOut"))
  MCMCplot(object = toSave$mcmc, params = c("betaPCohortOut"))
  
  priors <- runif(toSave$nIter * toSave$nChains, 0, 1)
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaPhiCohortOut"),
            pdf = FALSE, 
            priors = priors)
  
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaFlow"),
            pdf = FALSE, 
            priors = priors)
}

# run more iterations, if necessary
# nIterAdd <- 5000
# Cmcmc$run(nIterAdd, reset = FALSE)
# more_samples <- as.matrix(Cmcmc$mvSamples)
# 
# MCMCtrace(object = more_samples,
#           #ISB = FALSE,
#           #exact = TRUE, 
#           params = c("betaFlow"),
#           pdf = FALSE, 
#           priors = priors)

```

#### Get flow effect estimates
Flow effects vary across cohorts
```{r}
   #     betaInt +
   #     betaPhi[t,cohort[i]] + 
   #     betaFlow[1,season[t],cohort[i]] * flow[i,t] +
   #     betaFlow[2,season[t],cohort[i]] * flow[i,t] * flow[i,t]

# load current flow model
#load("C:/Users/bletcher/OneDrive - DOI/projects/westBrook-book/models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flow_2022-05-12 10.RData")

getPredictionsFlowCohort <- function(toSave, everyNIters = 10, flowStep = 0.5){

  mcmc <- toSave$mcmc
  ## betaInt
  predictorsBetaInt <- expand.grid(
    iter = seq(1, dim(mcmc$chain1)[1], everyNIters)
  )
  for(i in 1:nrow(predictorsBetaInt)){
    predictorsBetaInt$betaInt[i] <- mcmc$chain1[[ predictorsBetaInt[i, "iter"], "betaInt" ]]
  }
  
  
  ## betaFlow
  predictorsBetaFlow <- expand.grid(
    iter = seq(1, dim(mcmc$chain1)[1], everyNIters),
    season = 1:toSave$nSeasons,
    cohort = 1:toSave$nCohorts
  )
  
  for(i in 1:nrow(predictorsBetaFlow)){
    predictorsBetaFlow$betaFlow1[i] <- mcmc$chain1[[predictorsBetaFlow[i, "iter"], 
                                                   paste0("betaFlow[1, ", predictorsBetaFlow[i, "season"],
                                                          ", ",           predictorsBetaFlow[i, "cohort"],
                                                          "]")
                                                  ]]
    predictorsBetaFlow$betaFlow2[i] <- mcmc$chain1[[predictorsBetaFlow[i, "iter"], 
                                                   paste0("betaFlow[2, ", predictorsBetaFlow[i, "season"],
                                                          ", ",           predictorsBetaFlow[i, "cohort"],
                                                          "]")
                                                  ]]
  }
  
  ## betaPhi
  predictorsBetaPhi <- expand.grid(
    iter = seq(1, dim(mcmc$chain1)[1], everyNIters),
    cohort = 1:toSave$nCohorts
  )
  
  # this step is very slow for some reason......
  for(i in 1:nrow(predictorsBetaPhi)){
    predictorsBetaPhi$betaPhi[i] <- mcmc$chain1[[predictorsBetaPhi[i, "iter"], 
                                                   paste0("betaPhiCohort[", predictorsBetaPhi[i, "cohort"],
                                                          "]")
                                                ]]
  }

  predictorsAll <- expand.grid(
    iter = seq(1, dim(mcmc$chain1)[1], everyNIters),
    cohort = 1:toSave$nCohorts,
    season = 1:toSave$nSeasons,
    flow = seq(-1.5, 1.5, flowStep)
  )
  
  preds <- predictorsAll %>%
    left_join(predictorsBetaInt) %>%
    left_join(predictorsBetaFlow) %>%
    left_join(predictorsBetaPhi) %>%
    mutate(predPhi = plogis(betaInt + betaPhi + betaFlow1 * flow + betaFlow2 * flow^2))
  
  return(preds)
}

predFlowCohort <- getPredictionsFlowCohort(toSave, everyNIters = 2)

```

#### Plot flow predictions phiT_pT_cohort_flowCohort
```{r}
ggplot(predFlowCohort, aes(flow, predPhi, group = iter)) +
  geom_line(alpha = 0.025) +
  facet_grid(season ~ cohort)

# ggplot(predFlowCohort %>% filter(season ==1, cohort == 6), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.5) +
#   facet_grid(cohort ~ season)
# 
# ggplot(predFlowCohort %>% filter(cohort == 3), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.1) +
#   facet_wrap( ~ season)
# 
# ggplot(predFlowCohort %>% filter(season ==1), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.1) +
#   facet_wrap(~ cohort)

```

### Model phiT_pT_cohort_flowCohortHier
Flow effects vary by cohort, hierarchical across cohorts
#### Set up and run model
```{r phiT_pT_cohort_flowCohortHier}

# Following https://oliviergimenez.github.io/bayesian-cr-workshop/worksheets/4_demo.html
if (rerunSurivalModels) {

  y <- eh$eh
  nCohorts <- nrow(unique(eh$cohorts))
  nSeasons <- nrow(unique(eh$seasons))
  seasonArray <- c(3,4,1,2,3,4,1,2,3,4,1,2)
  
  hmm.phiT_pT_cohort_flowCohortHier <- nimbleCode({
    delta[1] <- 1                    # Pr(alive t = 1) = 1
    delta[2] <- 0                    # Pr(dead t = 1) = 0
    
    for (i in 1:N){
      for (t in 1:(T-1)){ # loop over time
        logit(phi[t,i]) <- 
          betaInt +
          betaPhi[t,cohort[i]] + 
          betaFlow[1,season[t],cohort[i]] * flow[i,t] +
          betaFlow[2,season[t],cohort[i]] * flow[i,t] * flow[i,t]
           # prior survival
        
        gamma[1,1,t,i] <- phi[t,i]         # Pr(alive t -> alive t+1)
        gamma[1,2,t,i] <- 1 - phi[t,i]     # Pr(alive t -> dead t+1)
        gamma[2,1,t,i] <- 0              # Pr(dead t -> alive t+1)
        gamma[2,2,t,i] <- 1              # Pr(dead t -> dead t+1)
        
        logit(p[t,i]) <- betaP[t,cohort[i]]             # prior detection
        omega[1,1,t,i] <- 1 - p[t,i]       # Pr(alive t -> non-detected t)
        omega[1,2,t,i] <- p[t,i]           # Pr(alive t -> detected t)
        omega[2,1,t,i] <- 1              # Pr(dead t -> non-detected t)
        omega[2,2,t,i] <- 0              # Pr(dead t -> detected t)
      }
    }
    
    betaInt ~ dnorm(0,1)
    betaFlowTop[1] ~ dnorm(0,1)
    betaFlowTop[2] ~ dnorm(0,1)
    
    for (c in 1:nCohorts){
      # mean values
      betaPhiCohort[c] ~ dnorm(0,1)
      betaPCohort[c] ~ dnorm(0,1)
      betaFlowCohort[1,c] ~ dnorm(betaFlowTop[1],1)
      betaFlowCohort[2,c] ~ dnorm(betaFlowTop[2],1)
      for (t in 1:(T-1)){ 
        betaPhi[t,c] ~ dnorm(betaPhiCohort[c],1)
        betaP[t,c] ~ dnorm(betaPCohort[c],1)
      }
    }
    
    # back-transform for examining output
    for (c in 1:nCohorts){
        betaPhiCohortOut[c] <- 1/(1 + exp(-betaPhiCohort[c]))
        betaPCohortOut[c] <- 1/(1 + exp(-betaPCohort[c]))
      for (t in 1:(T-1)){ 
        betaPhiOut[t,c] <- 1/(1 + exp(-betaPhi[t,c]))
        betaPOut[t,c] <- 1/(1 + exp(-betaP[t,c])) 
      }
    }
    
    for (s in 1:nSeasons){
      for (c in 1:nCohorts){
        betaFlow[1,s,c] ~ dnorm(betaFlowCohort[1,c],1)
        betaFlow[2,s,c] ~ dnorm(betaFlowCohort[2,c],1)
      }   
    }
    
    # likelihood
    for (i in 1:N){
      z[i,first[i]] ~ dcat(delta[1:2])
      for (j in (first[i]+1):(last[i])){
        z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, j-1, i])
        y[i,j] ~ dcat(omega[z[i,j], 1:2, j-1, i])
      }
    }
  })
    
  first <- eh$first #apply(y, 1, function(x) min(which(x !=0)))
  last <- eh$last
  cohort = ((eh$cohorts) - min(eh$cohorts) + 1)$cohort #can't be a data frame or tibble
  
  myConstants <- list(N = nrow(y), 
                       T = ncol(y), 
                       first = first,
                       last = last,
                       cohort = cohort, 
                       nCohorts = nCohorts,
                       season = seasonArray, #eh$seasons$season,
                       flow = eh$flow
                       )
  
  myData <- list(y = y + 1)
  
  zinits <- y + 1 # non-detection -> alive
  zinits[zinits == 2] <- 1 # dead -> alive
  
  zInitsNA <- ifelse(is.na(eh$flow), NA, 1)
  
  initialValues <- function() list(
    betaInt = rnorm(1, 0, 1),
    phi = array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
    p =   array(runif((myConstants$T - 1) * myConstants$N, 0, 1),c((myConstants$T - 1), myConstants$N)),
    z = zInitsNA,
    betaPhi = array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
    betaP =   array(runif((myConstants$T - 1) * nCohorts, 0, 1),c((myConstants$T - 1), nCohorts)),
    betaPhiCohort = array(runif(nCohorts, 0, 1),c(nCohorts)),
    betaPCohort =   array(runif(nCohorts, 0, 1),c(nCohorts)),
    betaFlow = array(rnorm(2 * 4 * nCohorts, 0, 1), c(2, 4, nCohorts)),
    betaFlowCohort = array(rnorm(2 * nCohorts, 0, 1), c(2, nCohorts)),
    betaFlowTop = rnorm(2, 0, 1)
  )
  
  parametersToSave <- c("betaInt", 
                        "betaPhi", "betaP", "betaPhiCohort", "betaPCohort",
                        "betaPhiOut", "betaPOut", "betaPhiCohortOut", "betaPCohortOut", 
                        "betaFlow",
                        "betaFlowCohort", "betaFlowTop")  
  nIter <- 30000
  nBurnin <- 15000
  nChains <- 2
  thinRate <- 5
  
  start = Sys.time()
  
  Rmodel <- nimbleModel(
    code = hmm.phiT_pT_cohort_flowCohortHier, 
    constants = myConstants,
    data = myData,              
    inits = initialValues(),
    calculate = FALSE
  )
  conf <- configureMCMC(
    Rmodel,
    monitors = parametersToSave
  )
  
  Rmcmc <- buildMCMC(conf, useConjugacy = FALSE)
  Cmodel <- compileNimble(Rmodel)
  Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
  
  mcmc.phiT_pT_cohort_flowCohortHier <- runMCMC(
    Cmcmc, 
    niter = nIter, 
    nburnin = nBurnin, 
    thin = thinRate, 
    nchains = nChains
  )
  
  end <- Sys.time()
  
  elapsed_phiT_pT_cohort_flowCohortHier <- end - start
  toSave <- list(
    mcmc = mcmc.phiT_pT_cohort_flowCohortHier, 
    elapsed = elapsed_phiT_pT_cohort_flowCohortHier,
    name = "phiT_pT_cohort_flowCohortHier",
    myConstants = myConstants, 
    nIter = nIter, 
    nBurnin = nBurnin,
    thinRate = thinRate, 
    nSeasons = nSeasons, 
    nCohorts = nCohorts,
    nChains = nChains
  )
  save(toSave, file = paste0('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohortHier_', substr(end,1,13), '.RData'))
  save(toSave, file = './models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohortHier_mostRecent.RData')
} else {
  load('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohortHier_mostRecent.RData')
}
# could consider forward algo to speed up convergence (https://oliviergimenez.github.io/banana-book/hmmcapturerecapture.html#nimble-implementation-1)

if(plotMCMCOutput) {

  #MCMCsummary(object = mcmc.phiT_pT_cohort_flowHier, round = 2)
  #MCMCplot(object = mcmc.phiT_pT_cohort_flowHier, params = "betaPhiOut")
  MCMCplot(object = toSave$mcmc, params = "betaFlowTop")
  MCMCplot(object = toSave$mcmc, params = "betaFlow")# 
  MCMCplot(object = toSave$mcmc, params = c("betaPhiCohortOut"))
  MCMCplot(object = toSave$mcmc, params = c("betaPCohortOut"))
  MCMCplot(object = toSave$mcmc, params = c("betaFlowCohort"))
  
  priors <- runif(toSave$nIter * toSave$nChains, 0, 1)
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaFlowTop"),
            pdf = FALSE, 
            priors = priors)
  
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaPhiCohortOut"),
            pdf = FALSE, 
            priors = priors)
  
  MCMCtrace(object = toSave$mcmc,
            #ISB = FALSE,
            #exact = TRUE, 
            params = c("betaFlow"),
            pdf = FALSE, 
            priors = priors)
}

# run more iterations, if necessary
# nIterAdd <- 5000
# Cmcmc$run(nIterAdd, reset = FALSE)
# more_samples <- as.matrix(Cmcmc$mvSamples)
# 
# MCMCtrace(object = more_samples,
#           #ISB = FALSE,
#           #exact = TRUE, 
#           params = c("betaFlow"),
#           pdf = FALSE, 
#           priors = priors)

```

#### Get flow effect estimates
Flow effects vary across cohorts - hierarchical
```{r}
   #     betaInt +
   #     betaPhi[t,cohort[i]] + 
   #     betaFlow[1,season[t],cohort[i]] * flow[i,t] +
   #     betaFlow[2,season[t],cohort[i]] * flow[i,t] * flow[i,t]

load('./models/cmrFlowWB/runsOut/mcmc_phiT_pT_cohort_flowCohortHier_mostRecent.RData')
predFlowCohortHier <- getPredictionsFlowCohort(toSave, everyNIters = 2)

```

#### Plot predictions
```{r}
ggplot(predFlowCohortHier, aes(flow, predPhi, group = iter)) +
  geom_line(alpha = 0.025) +
  facet_grid(season ~ cohort)

# ggplot(predFlowCohortHier %>% filter(season ==1, cohort == 6), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.5) +
#   facet_grid(cohort ~ season)
# 
# ggplot(predFlowCohortHier %>% filter(cohort == 3), aes(flow, predPhi, group = iter)) +
#   geom_line(alpha = 0.1) +
#   facet_wrap( ~ season)
# 
# ggplot(predFlowCohortHier %>% filter(season ==3), aes(flow, predPhi, group = iter)) +
  # geom_line(alpha = 0.1) +
  # facet_wrap(~ cohort)

```

#### BetaflowTop predictions
```{r}

getPredictionsFlowTop <- function(toSave, everyNIters = 10, flowStep = 0.5){

  mcmc <- toSave$mcmc
  
  ## betaFlow
  predictorsBetaFlowTop <- expand.grid(
    iter = seq(1, dim(mcmc$chain1)[1], everyNIters),
    var = 1:2,
     flow = seq(-1.5, 1.5, flowStep)
  )
  
  for(i in 1:nrow(predictorsBetaFlowTop)){
    predictorsBetaFlowTop$betaFlowTop1[i] <- mcmc$chain1[[predictorsBetaFlowTop[i, "iter"], 
                                                         1
                                                        ]]
    predictorsBetaFlowTop$betaFlowTop2[i] <- mcmc$chain1[[predictorsBetaFlowTop[i, "iter"], 
                                                         2
                                                        ]]
  }

  preds <- predictorsBetaFlowTop %>%
    mutate(predPhi = plogis(betaFlowTop1 * flow + betaFlowTop2 * flow * flow))
  
  return(preds)
}

predBetaFlowTop <- getPredictionsFlowTop(toSave, everyNIters = 10)

ggplot(predBetaFlowTop, aes(flow, predPhi, group = iter)) +
  geom_line() #+
  #facet_wrap(~iter)

ggplot(predBetaFlowTop, aes(betaFlowTop1, betaFlowTop2)) +
  geom_point()
```


### Compare models
```{r compare models}

#data.frame(model = c("(phi,p)",
#                     "(phit,pt)"),
#           WAIC = c(mcmc.phi_p, 
#                    mcmc.phiT_pT))


```

